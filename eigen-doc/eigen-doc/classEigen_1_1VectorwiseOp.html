<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Eigen: Eigen::VectorwiseOp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.3.7</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classEigen_1_1VectorwiseOp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1VectorwiseOp-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::VectorwiseOp Class Reference<div class="ingroups"><a class="el" href="group__DenseMatrixManipulation__chapter.html">Dense matrix and array manipulation</a> &raquo; <a class="el" href="group__DenseMatrixManipulation__Reference.html">Reference</a> &raquo; <a class="el" href="group__Core__Module.html">Core module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pseudo expression providing partial reduction operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>the type of the object on which to do partial reductions </td></tr>
    <tr><td class="paramname">Direction</td><td>indicates the direction of the redux (<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7ae2efac6e74ecab5e3b0b1561c5ddf83e">Vertical</a> or <a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7a961c62410157b64033839488f4d7f7e4">Horizontal</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>This class represents a pseudo expression with partial reduction features. It is the return type of <a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a> and <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> and most of the time this is the only way it is used.</p>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().sum() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each column:&quot;</span></div>
<div class="line">     &lt;&lt; endl &lt;&lt; m.cwiseAbs().colwise().maxCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each column:
  1.04  0.815 -0.238
Here is the maximum absolute value of each column:
 0.68 0.823 0.536
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a>, class <a class="el" href="classEigen_1_1PartialReduxExpr.html" title="Generic expression of a partially reduxed matrix.">PartialReduxExpr</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a018a40a3db90aaf640d4789fe5a459f5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a018a40a3db90aaf640d4789fe5a459f5">Index</a></td></tr>
<tr class="separator:a018a40a3db90aaf640d4789fe5a459f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cda87d46a9609db5216960d04499533"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a0cda87d46a9609db5216960d04499533">all</a> () const</td></tr>
<tr class="separator:a0cda87d46a9609db5216960d04499533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e10bbdc2871f8a918a2002938904368"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6e10bbdc2871f8a918a2002938904368">any</a> () const</td></tr>
<tr class="separator:a6e10bbdc2871f8a918a2002938904368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505388d0a4f06d681994bfc358b98189"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a505388d0a4f06d681994bfc358b98189">blueNorm</a> () const</td></tr>
<tr class="separator:a505388d0a4f06d681994bfc358b98189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2591cc4cd7c32708b35cf143c55acf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#afe2591cc4cd7c32708b35cf143c55acf">count</a> () const</td></tr>
<tr class="separator:afe2591cc4cd7c32708b35cf143c55acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7797771a02222159dcacf02a01db08"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ga7b7797771a02222159dcacf02a01db08"><td class="memTemplItemLeft" align="right" valign="top">const CrossReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga7b7797771a02222159dcacf02a01db08">cross</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ga7b7797771a02222159dcacf02a01db08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b9f1498d5977737ef6eb32a04b12311"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">HNormalizedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga8b9f1498d5977737ef6eb32a04b12311">hnormalized</a> () const</td></tr>
<tr class="memdesc:ga8b9f1498d5977737ef6eb32a04b12311"><td class="mdescLeft">&#160;</td><td class="mdescRight">column or row-wise homogeneous normalization  <a href="group__Geometry__Module.html#ga8b9f1498d5977737ef6eb32a04b12311">More...</a><br /></td></tr>
<tr class="separator:ga8b9f1498d5977737ef6eb32a04b12311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7eeaaf17a0fca2e2296d5b3beca9b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Homogeneous.html">HomogeneousReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gac7eeaaf17a0fca2e2296d5b3beca9b3d">homogeneous</a> () const</td></tr>
<tr class="separator:gac7eeaaf17a0fca2e2296d5b3beca9b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa6863c4be40a37e82852d8d0ef3bed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a8fa6863c4be40a37e82852d8d0ef3bed">hypotNorm</a> () const</td></tr>
<tr class="separator:a8fa6863c4be40a37e82852d8d0ef3bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a28531b7b27124bd3d76401f6409fe6"><td class="memTemplParams" colspan="2">template&lt;int p&gt; </td></tr>
<tr class="memitem:a2a28531b7b27124bd3d76401f6409fe6"><td class="memTemplItemLeft" align="right" valign="top">const LpNormReturnType&lt; p &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a2a28531b7b27124bd3d76401f6409fe6">lpNorm</a> () const</td></tr>
<tr class="separator:a2a28531b7b27124bd3d76401f6409fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59985ad00285b89f0bcbb642e066bf58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a59985ad00285b89f0bcbb642e066bf58">maxCoeff</a> () const</td></tr>
<tr class="separator:a59985ad00285b89f0bcbb642e066bf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dadd658f4fc1f395ff6c2210a75a790"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MeanReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7dadd658f4fc1f395ff6c2210a75a790">mean</a> () const</td></tr>
<tr class="separator:a7dadd658f4fc1f395ff6c2210a75a790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770f60d202082341d7b615e2c776e7a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a770f60d202082341d7b615e2c776e7a0">minCoeff</a> () const</td></tr>
<tr class="separator:a770f60d202082341d7b615e2c776e7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c261de41bc71b48299ab163878a798"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">NormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a76c261de41bc71b48299ab163878a798">norm</a> () const</td></tr>
<tr class="separator:a76c261de41bc71b48299ab163878a798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef64b8313ce3b23ed491ef336f85dda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7ef64b8313ce3b23ed491ef336f85dda">normalize</a> ()</td></tr>
<tr class="separator:a7ef64b8313ce3b23ed491ef336f85dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf116d64d34a905a1f28e65c9d7119ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt; typename ReturnType&lt; internal::member_norm, RealScalar &gt;::Type &gt;::Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#abf116d64d34a905a1f28e65c9d7119ef">normalized</a> () const</td></tr>
<tr class="separator:abf116d64d34a905a1f28e65c9d7119ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c60d513ccac48a83dfd3844d16495df"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a1c60d513ccac48a83dfd3844d16495df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_product_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a1c60d513ccac48a83dfd3844d16495df">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a1c60d513ccac48a83dfd3844d16495df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceec61a73b4f1ee44fbeade9c11100ff"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aceec61a73b4f1ee44fbeade9c11100ff"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aceec61a73b4f1ee44fbeade9c11100ff">operator*=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:aceec61a73b4f1ee44fbeade9c11100ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3cf71a4d1ccb3bfff0247c0c00eee9"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a6d3cf71a4d1ccb3bfff0247c0c00eee9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_sum_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6d3cf71a4d1ccb3bfff0247c0c00eee9">operator+</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a6d3cf71a4d1ccb3bfff0247c0c00eee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340bb83eed6010dcbce344e71d47893"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aa340bb83eed6010dcbce344e71d47893"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa340bb83eed6010dcbce344e71d47893">operator+=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:aa340bb83eed6010dcbce344e71d47893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4220da702b7975dc0a493201f87000cd"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a4220da702b7975dc0a493201f87000cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_difference_op&lt; Scalar, typename OtherDerived::Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4220da702b7975dc0a493201f87000cd">operator-</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a4220da702b7975dc0a493201f87000cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231ac6c09c2143474eb934f32066600a"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a231ac6c09c2143474eb934f32066600a"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a231ac6c09c2143474eb934f32066600a">operator-=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a231ac6c09c2143474eb934f32066600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aa8ac6cda85e83660182e2fa6f9529"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac6aa8ac6cda85e83660182e2fa6f9529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_quotient_op&lt; Scalar &gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ac6aa8ac6cda85e83660182e2fa6f9529">operator/</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ac6aa8ac6cda85e83660182e2fa6f9529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4be05a3e179f013ae12a910d74f165c"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af4be05a3e179f013ae12a910d74f165c"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#af4be05a3e179f013ae12a910d74f165c">operator/=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:af4be05a3e179f013ae12a910d74f165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0102341b5c631898b7ba2ea7dea10b"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a9c0102341b5c631898b7ba2ea7dea10b"><td class="memTemplItemLeft" align="right" valign="top">ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a9c0102341b5c631898b7ba2ea7dea10b">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a9c0102341b5c631898b7ba2ea7dea10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240956aa151db2797667e539e0d78199"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a240956aa151db2797667e539e0d78199">prod</a> () const</td></tr>
<tr class="separator:a240956aa151db2797667e539e0d78199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37a750caaab9a74c50d5fbfb48b3829"><td class="memTemplParams" colspan="2">template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:ae37a750caaab9a74c50d5fbfb48b3829"><td class="memTemplItemLeft" align="right" valign="top">const ReduxReturnType&lt; BinaryOp &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ae37a750caaab9a74c50d5fbfb48b3829">redux</a> (const BinaryOp &amp;func=BinaryOp()) const</td></tr>
<tr class="separator:ae37a750caaab9a74c50d5fbfb48b3829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7360c9a7aaf12f4f1058ffc559af39ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7360c9a7aaf12f4f1058ffc559af39ab">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a018a40a3db90aaf640d4789fe5a459f5">Index</a> factor) const</td></tr>
<tr class="separator:a7360c9a7aaf12f4f1058ffc559af39ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b20a6de87965b36228c7f0ae48d5a17"><td class="memTemplParams" colspan="2">template&lt;int Factor&gt; </td></tr>
<tr class="memitem:a0b20a6de87965b36228c7f0ae48d5a17"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; ExpressionType, isVertical *Factor+isHorizontal, isHorizontal *Factor+isVertical &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a0b20a6de87965b36228c7f0ae48d5a17">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a018a40a3db90aaf640d4789fe5a459f5">Index</a> factor=Factor) const</td></tr>
<tr class="separator:a0b20a6de87965b36228c7f0ae48d5a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43e4714f44e5a4bfd740b6432171290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#af43e4714f44e5a4bfd740b6432171290">reverse</a> ()</td></tr>
<tr class="separator:af43e4714f44e5a4bfd740b6432171290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc243a46a662bbab6a8c07db5e71939f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#afc243a46a662bbab6a8c07db5e71939f">reverse</a> () const</td></tr>
<tr class="separator:afc243a46a662bbab6a8c07db5e71939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1013e0bb0c54b285d52fb113341595c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ae1013e0bb0c54b285d52fb113341595c">reverseInPlace</a> ()</td></tr>
<tr class="separator:ae1013e0bb0c54b285d52fb113341595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140007b32c826b7992ffb1d588dc8611"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a140007b32c826b7992ffb1d588dc8611">squaredNorm</a> () const</td></tr>
<tr class="separator:a140007b32c826b7992ffb1d588dc8611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d5faf7979ddcda5cdc6e1f51dac336"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aa6d5faf7979ddcda5cdc6e1f51dac336">stableNorm</a> () const</td></tr>
<tr class="separator:aa6d5faf7979ddcda5cdc6e1f51dac336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee79661fc144ddc5ff4b5508751fa442"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aee79661fc144ddc5ff4b5508751fa442">sum</a> () const</td></tr>
<tr class="separator:aee79661fc144ddc5ff4b5508751fa442"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a018a40a3db90aaf640d4789fe5a459f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018a40a3db90aaf640d4789fe5a459f5">&#9670;&nbsp;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceEigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a class="el" href="classEigen_1_1VectorwiseOp.html#a018a40a3db90aaf640d4789fe5a459f5">Eigen::VectorwiseOp::Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>since <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0cda87d46a9609db5216960d04499533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cda87d46a9609db5216960d04499533">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a> Eigen::VectorwiseOp::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>all</b> coefficients of each respective column (or row) are <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ae42ab60296c120e9f45ce3b44e1761a4">DenseBase::all()</a> </dd></dl>

</div>
</div>
<a id="a6e10bbdc2871f8a918a2002938904368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e10bbdc2871f8a918a2002938904368">&#9670;&nbsp;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a> Eigen::VectorwiseOp::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>at</b> <b>least</b> one coefficient of each respective column (or row) is <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#abfbf4cb72dd577e62fbe035b1c53e695">DenseBase::any()</a> </dd></dl>

</div>
</div>
<a id="a505388d0a4f06d681994bfc358b98189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505388d0a4f06d681994bfc358b98189">&#9670;&nbsp;</a></span>blueNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a> Eigen::VectorwiseOp::blueNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, using Blue's algorithm. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::blueNorm() </dd></dl>

</div>
</div>
<a id="afe2591cc4cd7c32708b35cf143c55acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2591cc4cd7c32708b35cf143c55acf">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a> Eigen::VectorwiseOp::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing the number of <code>true</code> coefficients of each respective column (or row). This expression can be assigned to a vector whose entries have the same type as is used to index entries of the original matrix; for dense matrices, this is <code>std::ptrdiff_t</code> .</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">Matrix&lt;ptrdiff_t, 3, 1&gt; res = (m.array() &gt;= 0.5).rowwise().count();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the count of elements larger or equal than 0.5 of each row:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; res &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the count of elements larger or equal than 0.5 of each row:
2
2
1
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a229be090c665b9bf7d1fcdfd1ab6e0c1">DenseBase::count()</a> </dd></dl>

</div>
</div>
<a id="a8fa6863c4be40a37e82852d8d0ef3bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa6863c4be40a37e82852d8d0ef3bed">&#9670;&nbsp;</a></span>hypotNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a> Eigen::VectorwiseOp::hypotNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow using a concatenation of hypot() calls. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::hypotNorm() </dd></dl>

</div>
</div>
<a id="a2a28531b7b27124bd3d76401f6409fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a28531b7b27124bd3d76401f6409fe6">&#9670;&nbsp;</a></span>lpNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const LpNormReturnType&lt;p&gt;::Type Eigen::VectorwiseOp::lpNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the norm of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the norm of each column:
 0.91  1.18 0.771
</pre><dl class="section see"><dt>See also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a id="a59985ad00285b89f0bcbb642e066bf58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59985ad00285b89f0bcbb642e066bf58">&#9670;&nbsp;</a></span>maxCoeff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a> Eigen::VectorwiseOp::maxCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the largest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().maxCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the maximum of each column:
 0.68 0.823 0.536
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a6f3710cb36d81cd490b3a2ff3556471b">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a id="a7dadd658f4fc1f395ff6c2210a75a790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dadd658f4fc1f395ff6c2210a75a790">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MeanReturnType</a> Eigen::VectorwiseOp::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the mean of each column (or row) of the referenced expression.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a21ac6c0419a72ad7a88ea0bc189017d7">DenseBase::mean()</a> </dd></dl>

</div>
</div>
<a id="a770f60d202082341d7b615e2c776e7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770f60d202082341d7b615e2c776e7a0">&#9670;&nbsp;</a></span>minCoeff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a> Eigen::VectorwiseOp::minCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the smallest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the minimum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().minCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the minimum of each column:
-0.211 -0.605 -0.444
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aaeb695853e9a28ba1dd54861d0cd9d8f">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a id="a76c261de41bc71b48299ab163878a798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c261de41bc71b48299ab163878a798">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">NormReturnType</a> Eigen::VectorwiseOp::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the norm of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().norm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the norm of each column:
 0.91  1.18 0.771
</pre><dl class="section see"><dt>See also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a id="a7ef64b8313ce3b23ed491ef336f85dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef64b8313ce3b23ed491ef336f85dda">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::VectorwiseOp::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalize in-place each row or columns of the referenced matrix. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ad16303c47ba36f7a41ea264cb26bceb6">MatrixBase::normalize()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#abf116d64d34a905a1f28e65c9d7119ef">normalized()</a> </dd></dl>

</div>
</div>
<a id="abf116d64d34a905a1f28e65c9d7119ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf116d64d34a905a1f28e65c9d7119ef">&#9670;&nbsp;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt;typename ReturnType&lt;internal::member_norm,RealScalar&gt;::Type&gt;::Type&gt; Eigen::VectorwiseOp::normalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression where each column (or row) of the referenced matrix are normalized. The referenced matrix is <b>not</b> modified. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a5cf2fd4c57e59604fd4116158fd34308">MatrixBase::normalized()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a7ef64b8313ce3b23ed491ef336f85dda">normalize()</a> </dd></dl>

</div>
</div>
<a id="a1c60d513ccac48a83dfd3844d16495df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c60d513ccac48a83dfd3844d16495df">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; Eigen::VectorwiseOp::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression where each subvector is the product of the vector <em>other</em> by the corresponding subvector of <code>*this</code> </p>

</div>
</div>
<a id="aceec61a73b4f1ee44fbeade9c11100ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceec61a73b4f1ee44fbeade9c11100ff">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; Eigen::VectorwiseOp::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiples each subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a6d3cf71a4d1ccb3bfff0247c0c00eee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3cf71a4d1ccb3bfff0247c0c00eee9">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_sum_op&lt;Scalar,typename OtherDerived::Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; Eigen::VectorwiseOp::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression of the sum of the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="aa340bb83eed6010dcbce344e71d47893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340bb83eed6010dcbce344e71d47893">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; Eigen::VectorwiseOp::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a4220da702b7975dc0a493201f87000cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4220da702b7975dc0a493201f87000cd">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_difference_op&lt;Scalar,typename OtherDerived::Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; Eigen::VectorwiseOp::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression of the difference between each subvector of <code>*this</code> and the vector <em>other</em> </p>

</div>
</div>
<a id="a231ac6c09c2143474eb934f32066600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231ac6c09c2143474eb934f32066600a">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; Eigen::VectorwiseOp::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Substracts the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="ac6aa8ac6cda85e83660182e2fa6f9529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aa8ac6cda85e83660182e2fa6f9529">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename ExtendedType&lt;OtherDerived&gt;::Type&gt; Eigen::VectorwiseOp::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the expression where each subvector is the quotient of the corresponding subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="af4be05a3e179f013ae12a910d74f165c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4be05a3e179f013ae12a910d74f165c">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; Eigen::VectorwiseOp::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divides each subvector of <code>*this</code> by the vector <em>other</em> </p>

</div>
</div>
<a id="a9c0102341b5c631898b7ba2ea7dea10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0102341b5c631898b7ba2ea7dea10b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ExpressionType&amp; Eigen::VectorwiseOp::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the vector <em>other</em> to each subvector of <code>*this</code> </p>

</div>
</div>
<a id="a240956aa151db2797667e539e0d78199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240956aa151db2797667e539e0d78199">&#9670;&nbsp;</a></span>prod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a> Eigen::VectorwiseOp::prod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the product of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the product of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().prod() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the product of each row:
 -0.134
-0.0933
  0.152
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#af119d9a4efe5a15cd83c1ccdf01b3a4f">DenseBase::prod()</a> </dd></dl>

</div>
</div>
<a id="ae37a750caaab9a74c50d5fbfb48b3829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37a750caaab9a74c50d5fbfb48b3829">&#9670;&nbsp;</a></span>redux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ReduxReturnType&lt;BinaryOp&gt;::Type Eigen::VectorwiseOp::redux </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>BinaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row or column vector expression of <code>*this</code> reduxed by <em>func</em> </dd></dl>
<p>The template parameter <em>BinaryOp</em> is the type of the functor of the custom redux operator. Note that func must be an associative operator.</p>
<dl class="section see"><dt>See also</dt><dd>class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations.">VectorwiseOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> </dd></dl>

</div>
</div>
<a id="a7360c9a7aaf12f4f1058ffc559af39ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7360c9a7aaf12f4f1058ffc559af39ab">&#9670;&nbsp;</a></span>replicate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a> Eigen::VectorwiseOp::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a018a40a3db90aaf640d4789fe5a459f5">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Vector3i v = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Vector3i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.rowwise().replicate(5) = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; v.rowwise().replicate(5) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the vector v:
 7
-2
 6
v.rowwise().replicate(5) = ...
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a7360c9a7aaf12f4f1058ffc559af39ab">VectorwiseOp::replicate()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="a0b20a6de87965b36228c7f0ae48d5a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b20a6de87965b36228c7f0ae48d5a17">&#9670;&nbsp;</a></span>replicate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Factor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt;ExpressionType,isVertical*Factor+isHorizontal,isHorizontal*Factor+isVertical&gt; Eigen::VectorwiseOp::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a018a40a3db90aaf640d4789fe5a459f5">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em> = <code>Factor</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p><div class="fragment"><div class="line">MatrixXi m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXi::Random</a>(2,3);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.colwise().replicate&lt;3&gt;() = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.colwise().replicate&lt;3&gt;() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6  9
-2  6 -6
m.colwise().replicate&lt;3&gt;() = ...
 7  6  9
-2  6 -6
 7  6  9
-2  6 -6
 7  6  9
-2  6 -6
</pre><dl class="section see"><dt>See also</dt><dd>VectorwiseOp::replicate(Index), <a class="el" href="classEigen_1_1DenseBase.html#a60dadfe80b813d808e91e4521c722a8e">DenseBase::replicate()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector.">Replicate</a> </dd></dl>

</div>
</div>
<a id="af43e4714f44e5a4bfd740b6432171290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43e4714f44e5a4bfd740b6432171290">&#9670;&nbsp;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a> Eigen::VectorwiseOp::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable matrix expression where each column (or row) are reversed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#afc243a46a662bbab6a8c07db5e71939f">reverse() const </a> </dd></dl>

</div>
</div>
<a id="afc243a46a662bbab6a8c07db5e71939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc243a46a662bbab6a8c07db5e71939f">&#9670;&nbsp;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> Eigen::VectorwiseOp::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix expression where each column (or row) are reversed.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">MatrixXi m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">MatrixXi::Random</a>(3,4);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the rowwise reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().reverse() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the colwise reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().reverse() &lt;&lt; endl;</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the rowise reverse of m:&quot;</span> &lt;&lt; endl</div>
<div class="line">&lt;&lt; m.rowwise().reverse()(1,0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 4.&quot;</span> &lt;&lt; endl;</div>
<div class="line"><span class="comment">//m.colwise().reverse()(1,0) = 4;</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
Here is the rowwise reverse of m:
 1 -3  6  7
 0  6  9 -2
 3 -5 -6  6
Here is the colwise reverse of m:
 6 -6 -5  3
-2  9  6  0
 7  6 -3  1
Here is the coefficient (1,0) in the rowise reverse of m:
0
Let us overwrite this coefficient with the value 4.
Now the matrix m is:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a> </dd></dl>

</div>
</div>
<a id="ae1013e0bb0c54b285d52fb113341595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1013e0bb0c54b285d52fb113341595c">&#9670;&nbsp;</a></span>reverseInPlace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::VectorwiseOp::reverseInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="classEigen_1_1VectorwiseOp.html#afc243a46a662bbab6a8c07db5e71939f">VectorwiseOp::reverse</a>: it reverses each column or row of <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p><ul>
<li>less error prone: doing the same operation with .<a class="el" href="classEigen_1_1VectorwiseOp.html#af43e4714f44e5a4bfd740b6432171290">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API enables reverse operations without the need for a temporary</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#adb8045155ea45f7961fc2a5170e1d921">DenseBase::reverseInPlace()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#af43e4714f44e5a4bfd740b6432171290">reverse()</a> </dd></dl>

</div>
</div>
<a id="a140007b32c826b7992ffb1d588dc8611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140007b32c826b7992ffb1d588dc8611">&#9670;&nbsp;</a></span>squaredNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a> Eigen::VectorwiseOp::squaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the squared norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the square norm of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().squaredNorm() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the square norm of each row:
0.928
 1.01
0.884
</pre><dl class="section see"><dt>See also</dt><dd>DenseBase::squaredNorm() </dd></dl>

</div>
</div>
<a id="aa6d5faf7979ddcda5cdc6e1f51dac336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d5faf7979ddcda5cdc6e1f51dac336">&#9670;&nbsp;</a></span>stableNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a> Eigen::VectorwiseOp::stableNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>DenseBase::stableNorm() </dd></dl>

</div>
</div>
<a id="aee79661fc144ddc5ff4b5508751fa442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee79661fc144ddc5ff4b5508751fa442">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a> Eigen::VectorwiseOp::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the sum of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p><div class="fragment"><div class="line">Matrix3d m = <a class="code" href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().sum() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p><pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each row:
 0.948
  1.15
-0.483
</pre><dl class="section see"><dt>See also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#addd7080d5c202795820e361768d0140c">DenseBase::sum()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ForwardDeclarations_8h_source.html">ForwardDeclarations.h</a></li>
<li><a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li>
<li><a class="el" href="Replicate_8h_source.html">Replicate.h</a></li>
<li><a class="el" href="Reverse_8h_source.html">Reverse.h</a></li>
<li><a class="el" href="Homogeneous_8h_source.html">Homogeneous.h</a></li>
<li><a class="el" href="OrthoMethods_8h_source.html">OrthoMethods.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassEigen_1_1DenseBase_html_ae814abb451b48ed872819192dc188c19"><div class="ttname"><a href="classEigen_1_1DenseBase.html#ae814abb451b48ed872819192dc188c19">Eigen::DenseBase::Random</a></div><div class="ttdeci">static const RandomReturnType Random()</div><div class="ttdef"><b>Definition:</b> Random.h:113</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a></li>
    <li class="footer">Generated on Fri Jul 24 2020 10:50:07 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
<!-- Matomo -->
<script type="text/javascript">
  var _paq = _paq || [];
  /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
  _paq.push(['trackPageView']);
  _paq.push(['enableLinkTracking']);
  (function() {
    var u="//stats.sylphide-consulting.com/matomo/";
    _paq.push(['setTrackerUrl', u+'piwik.php']);
    _paq.push(['setSiteId', '20']);
    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
  })();
</script>
<noscript><p><img src="//stats.sylphide-consulting.com/matomo/piwik.php?idsite=20&rec=1" style="border:0;" alt="" /></p></noscript>
<!-- End Matomo Code -->
</body>
</html>
